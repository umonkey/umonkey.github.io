{"version":3,"file":"props.D3mr3rPF.js","sources":["../../../../../../node_modules/svelte/src/internal/client/proxy.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/props.js"],"sourcesContent":["/** @import { ProxyMetadata, ProxyStateObject, Source } from '#client' */\nimport { DEV } from 'esm-env';\nimport { get, component_context, active_effect } from './runtime.js';\nimport {\n\tarray_prototype,\n\tget_descriptor,\n\tget_prototype_of,\n\tis_array,\n\tobject_prototype\n} from '../shared/utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { source, set } from './reactivity/sources.js';\nimport { STATE_SYMBOL, STATE_SYMBOL_METADATA } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {ProxyMetadata | null} [parent]\n * @param {Source<T>} [prev] dev mode only\n * @returns {T}\n */\nexport function proxy(value, parent = null, prev) {\n\t// if non-proxyable, or is already a proxy, return `value`\n\tif (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {\n\t\treturn value;\n\t}\n\n\tconst prototype = get_prototype_of(value);\n\n\tif (prototype !== object_prototype && prototype !== array_prototype) {\n\t\treturn value;\n\t}\n\n\t/** @type {Map<any, Source<any>>} */\n\tvar sources = new Map();\n\tvar is_proxied_array = is_array(value);\n\tvar version = source(0);\n\n\tif (is_proxied_array) {\n\t\t// We need to create the length source eagerly to ensure that\n\t\t// mutations to the array are properly synced with our proxy\n\t\tsources.set('length', source(/** @type {any[]} */ (value).length));\n\t}\n\n\t/** @type {ProxyMetadata} */\n\tvar metadata;\n\n\tif (DEV) {\n\t\tmetadata = {\n\t\t\tparent,\n\t\t\towners: null\n\t\t};\n\n\t\tif (prev) {\n\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t// @ts-expect-error\n\t\t\tconst prev_owners = prev.v?.[STATE_SYMBOL_METADATA]?.owners;\n\t\t\tmetadata.owners = prev_owners ? new Set(prev_owners) : null;\n\t\t} else {\n\t\t\tmetadata.owners =\n\t\t\t\tparent === null\n\t\t\t\t\t? component_context !== null\n\t\t\t\t\t\t? new Set([component_context.function])\n\t\t\t\t\t\t: null\n\t\t\t\t\t: new Set();\n\t\t}\n\t}\n\n\treturn new Proxy(/** @type {any} */ (value), {\n\t\tdefineProperty(_, prop, descriptor) {\n\t\t\tif (\n\t\t\t\t!('value' in descriptor) ||\n\t\t\t\tdescriptor.configurable === false ||\n\t\t\t\tdescriptor.enumerable === false ||\n\t\t\t\tdescriptor.writable === false\n\t\t\t) {\n\t\t\t\t// we disallow non-basic descriptors, because unless they are applied to the\n\t\t\t\t// target object — which we avoid, so that state can be forked — we will run\n\t\t\t\t// afoul of the various invariants\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants\n\t\t\t\te.state_descriptors_fixed();\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\ts = source(descriptor.value);\n\t\t\t\tsources.set(prop, s);\n\t\t\t} else {\n\t\t\t\tset(s, proxy(descriptor.value, metadata));\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tdeleteProperty(target, prop) {\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\tif (prop in target) {\n\t\t\t\t\tsources.set(prop, source(UNINITIALIZED));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// When working with arrays, we need to also ensure we update the length when removing\n\t\t\t\t// an indexed property\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n < ls.v) {\n\t\t\t\t\t\tset(ls, n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset(s, UNINITIALIZED);\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tget(target, prop, receiver) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn metadata;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar exists = prop in target;\n\n\t\t\t// create a source, but only if it's an own property and not a prototype property\n\t\t\tif (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {\n\t\t\t\ts = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata));\n\t\t\t\tsources.set(prop, s);\n\t\t\t}\n\n\t\t\tif (s !== undefined) {\n\t\t\t\tvar v = get(s);\n\n\t\t\t\t// In case of something like `foo = bar.map(...)`, foo would have ownership\n\t\t\t\t// of the array itself, while the individual items would have ownership\n\t\t\t\t// of the component that created bar. That means if we later do `foo[0].baz = 42`,\n\t\t\t\t// we could get a false-positive ownership violation, since the two proxies\n\t\t\t\t// are not connected to each other via the parent metadata relationship.\n\t\t\t\t// For this reason, we need to widen the ownership of the children\n\t\t\t\t// upon access when we detect they are not connected.\n\t\t\t\tif (DEV) {\n\t\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\t\tvar prop_metadata = v?.[STATE_SYMBOL_METADATA];\n\t\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn v === UNINITIALIZED ? undefined : v;\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop, receiver);\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t\tvar s = sources.get(prop);\n\t\t\t\tif (s) descriptor.value = get(s);\n\t\t\t} else if (descriptor === undefined) {\n\t\t\t\tvar source = sources.get(prop);\n\t\t\t\tvar value = source?.v;\n\n\t\t\t\tif (source !== undefined && value !== UNINITIALIZED) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn descriptor;\n\t\t},\n\n\t\thas(target, prop) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);\n\n\t\t\tif (\n\t\t\t\ts !== undefined ||\n\t\t\t\t(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t\t) {\n\t\t\t\tif (s === undefined) {\n\t\t\t\t\ts = source(has ? proxy(target[prop], metadata) : UNINITIALIZED);\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\n\t\t\t\tvar value = get(s);\n\t\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn has;\n\t\t},\n\n\t\tset(target, prop, value, receiver) {\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = prop in target;\n\n\t\t\t// variable.length = value -> clear all signals with index >= value\n\t\t\tif (is_proxied_array && prop === 'length') {\n\t\t\t\tfor (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {\n\t\t\t\t\tvar other_s = sources.get(i + '');\n\t\t\t\t\tif (other_s !== undefined) {\n\t\t\t\t\t\tset(other_s, UNINITIALIZED);\n\t\t\t\t\t} else if (i in target) {\n\t\t\t\t\t\t// If the item exists in the original, we need to create a uninitialized source,\n\t\t\t\t\t\t// else a later read of the property would result in a source being created with\n\t\t\t\t\t\t// the value of the original item at that index.\n\t\t\t\t\t\tother_s = source(UNINITIALIZED);\n\t\t\t\t\t\tsources.set(i + '', other_s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t\t// object property before writing to that property.\n\t\t\tif (s === undefined) {\n\t\t\t\tif (!has || get_descriptor(target, prop)?.writable) {\n\t\t\t\t\ts = source(undefined);\n\t\t\t\t\tset(s, proxy(value, metadata));\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thas = s.v !== UNINITIALIZED;\n\t\t\t\tset(s, proxy(value, metadata));\n\t\t\t}\n\n\t\t\tif (DEV) {\n\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\tvar prop_metadata = value?.[STATE_SYMBOL_METADATA];\n\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t}\n\t\t\t\tcheck_ownership(metadata);\n\t\t\t}\n\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t\tif (descriptor?.set) {\n\t\t\t\tdescriptor.set.call(receiver, value);\n\t\t\t}\n\n\t\t\tif (!has) {\n\t\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t\t// will not cause the length to be out of sync.\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n >= ls.v) {\n\t\t\t\t\t\tset(ls, n + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\townKeys(target) {\n\t\t\tget(version);\n\n\t\t\tvar own_keys = Reflect.ownKeys(target).filter((key) => {\n\t\t\t\tvar source = sources.get(key);\n\t\t\t\treturn source === undefined || source.v !== UNINITIALIZED;\n\t\t\t});\n\n\t\t\tfor (var [key, source] of sources) {\n\t\t\t\tif (source.v !== UNINITIALIZED && !(key in target)) {\n\t\t\t\t\town_keys.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn own_keys;\n\t\t},\n\n\t\tsetPrototypeOf() {\n\t\t\te.state_prototype_fixed();\n\t\t}\n\t});\n}\n\n/**\n * @param {Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\treturn value[STATE_SYMBOL];\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n","/** @import { Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport {\n\tactive_effect,\n\tget,\n\tcaptured_signals,\n\tset_active_effect,\n\tuntrack,\n\tupdate\n} from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport {\n\tBRANCH_EFFECT,\n\tLEGACY_DERIVED_PROP,\n\tLEGACY_PROPS,\n\tROOT_EFFECT,\n\tSTATE_SYMBOL\n} from '../constants.js';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nfunction with_parent_branch(fn) {\n\tvar effect = active_effect;\n\tvar previous_effect = active_effect;\n\n\twhile (effect !== null && (effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {\n\t\teffect = effect.parent;\n\t}\n\ttry {\n\t\tset_active_effect(effect);\n\t\treturn fn();\n\t} finally {\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\n\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t// or `createClassComponent(Component, props)`\n\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\tvar setter =\n\t\tget_descriptor(props, key)?.set ??\n\t\t(is_entry_props && bindable && key in props ? (v) => (props[key] = v) : undefined);\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = with_parent_branch(() =>\n\t\t\t(immutable ? derived : derived_safe_equal)(() => /** @type {V} */ (props[key]))\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode — prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode — prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly — the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = with_parent_branch(() =>\n\t\tderived(() => {\n\t\t\tvar parent_value = getter();\n\t\t\tvar child_value = get(inner_current_value);\n\n\t\t\tif (from_child) {\n\t\t\t\tfrom_child = false;\n\t\t\t\twas_from_child = true;\n\t\t\t\treturn child_value;\n\t\t\t}\n\n\t\t\twas_from_child = false;\n\t\t\treturn (inner_current_value.v = parent_value);\n\t\t})\n\t);\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (captured_signals !== null) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t\treturn get(current_value);\n\t};\n}\n"],"names":["proxy","value","parent","prev","STATE_SYMBOL","prototype","get_prototype_of","object_prototype","array_prototype","sources","is_proxied_array","is_array","version","source","metadata","_","prop","descriptor","e.state_descriptors_fixed","s","set","target","UNINITIALIZED","ls","n","update_version","receiver","exists","_a","get_descriptor","v","get","has","active_effect","i","other_s","own_keys","key","e.state_prototype_fixed","signal","d","get_proxied_value","is","a","b","spread_props_handler","p","is_function","desc","LEGACY_PROPS","keys","spread_props","props","with_parent_branch","fn","effect","previous_effect","BRANCH_EFFECT","ROOT_EFFECT","set_active_effect","flags","fallback","immutable","PROPS_IS_IMMUTABLE","runes","legacy_mode_flag","PROPS_IS_RUNES","bindable","PROPS_IS_BINDABLE","lazy","PROPS_IS_LAZY_INITIAL","is_store_sub","prop_value","capture_store_binding","is_entry_props","setter","fallback_value","fallback_dirty","fallback_used","get_fallback","untrack","e.props_invalid_value","getter","derived_getter","derived","derived_safe_equal","LEGACY_DERIVED_PROP","PROPS_IS_UPDATED","legacy_parent","mutation","from_child","was_from_child","inner_current_value","mutable_source","current_value","parent_value","child_value","safe_equals","captured_signals","new_value"],"mappings":"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","x_google_ignoreList":[0,1]}