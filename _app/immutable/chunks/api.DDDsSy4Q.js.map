{"version":3,"file":"api.DDDsSy4Q.js","sources":["../../../../../../node_modules/@sentry/sveltekit/build/esm/common/utils.js","../../../../../../node_modules/@sentry/sveltekit/build/esm/client/load.js","../../../../../../src/lib/stores/userStore.ts","../../../../../../src/lib/api.ts"],"sourcesContent":["/**\n * Determines if a thrown \"error\" is a Redirect object which SvelteKit users can throw to redirect to another route\n * see: https://kit.svelte.dev/docs/modules#sveltejs-kit-redirect\n * @param error the potential redirect error\n */\nfunction isRedirect(error) {\n  if (error == null || typeof error !== 'object') {\n    return false;\n  }\n  const hasValidLocation = 'location' in error && typeof error.location === 'string';\n  const hasValidStatus =\n    'status' in error && typeof error.status === 'number' && error.status >= 300 && error.status <= 308;\n  return hasValidLocation && hasValidStatus;\n}\n\n/**\n * Determines if a thrown \"error\" is a HttpError\n */\nfunction isHttpError(err) {\n  return typeof err === 'object' && err !== null && 'status' in err && 'body' in err;\n}\n\nexport { isHttpError, isRedirect };\n//# sourceMappingURL=utils.js.map\n","import { addNonEnumerableProperty, startSpan, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, handleCallbackErrors, objectify } from '@sentry/core';\nimport { captureException } from '@sentry/svelte';\nimport { isRedirect, isHttpError } from '../common/utils.js';\n\nfunction sendErrorToSentry(e) {\n  // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can\n  // store a seen flag on it.\n  const objectifiedErr = objectify(e);\n\n  // We don't want to capture thrown `Redirect`s as these are not errors but expected behaviour\n  // Neither 4xx errors, given that they are not valuable.\n  if (\n    isRedirect(objectifiedErr) ||\n    (isHttpError(objectifiedErr) && objectifiedErr.status < 500 && objectifiedErr.status >= 400)\n  ) {\n    return objectifiedErr;\n  }\n\n  captureException(objectifiedErr, {\n    mechanism: {\n      type: 'sveltekit',\n      handled: false,\n      data: {\n        function: 'load',\n      },\n    },\n  });\n\n  return objectifiedErr;\n}\n\n/**\n * Wrap load function with Sentry. This wrapper will\n *\n * - catch errors happening during the execution of `load`\n * - create a load span if performance monitoring is enabled\n * - attach tracing Http headers to `fetch` requests if performance monitoring is enabled to get connected traces.\n * - add a fetch breadcrumb for every `fetch` request\n *\n * Note that tracing Http headers are only attached if the url matches the specified `tracePropagationTargets`\n * entries to avoid CORS errors.\n *\n * @param origLoad SvelteKit user defined load function\n */\n// The liberal generic typing of `T` is necessary because we cannot let T extend `Load`.\n// This function needs to tell TS that it returns exactly the type that it was called with\n// because SvelteKit generates the narrowed down `PageLoad` or `LayoutLoad` types\n// at build time for every route.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction wrapLoadWithSentry(origLoad) {\n  return new Proxy(origLoad, {\n    apply: (wrappingTarget, thisArg, args) => {\n      // Type casting here because `T` cannot extend `Load` (see comment above function signature)\n      const event = args[0] ;\n\n      // Check if already wrapped\n      if (event.__sentry_wrapped__) {\n        return wrappingTarget.apply(thisArg, args);\n      }\n\n      const patchedEvent = {\n        ...event,\n      };\n\n      addNonEnumerableProperty(patchedEvent , '__sentry_wrapped__', true);\n\n      // Accessing any member of `event.route` causes SvelteKit to invalidate the\n      // client-side universal `load` function's data prefetched data, causing another reload on the actual navigation.\n      // To work around this, we use `Object.getOwnPropertyDescriptor` which doesn't invoke the proxy.\n      const routeIdDescriptor = event.route && Object.getOwnPropertyDescriptor(event.route, 'id');\n      // First, we try to access the route id from the property descriptor.\n      // This will only work for @sveltejs/kit >= 1.24.0\n      const routeIdFromDescriptor = routeIdDescriptor && (routeIdDescriptor.value );\n      // If routeIdFromDescriptor is undefined, we fall back to the old behavior of accessing\n      // `event.route.id` directly. This will still cause invalidations but we get a route name.\n      const routeId = routeIdFromDescriptor || event.route.id;\n\n      return startSpan(\n        {\n          op: 'function.sveltekit.load',\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.sveltekit',\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: routeId ? 'route' : 'url',\n          },\n          name: routeId ? routeId : event.url.pathname,\n        },\n        () => handleCallbackErrors(() => wrappingTarget.apply(thisArg, [patchedEvent]), sendErrorToSentry),\n      );\n    },\n  });\n}\n\nexport { wrapLoadWithSentry };\n//# sourceMappingURL=load.js.map\n","import { writable, derived } from 'svelte/store';\nimport type { IUser } from '$lib/types';\n\ntype UserMap = {\n\t[key: string]: IUser;\n};\n\nexport const userStore = writable<UserMap>({});\n\nexport const getUser = derived(userStore, ($userStore) => {\n\treturn (id) => $userStore[id] ?? undefined;\n});\n\nexport const addUsers = (users: IUser[]) => {\n\tuserStore.update((store) => {\n\t\tfor (const user of users) {\n\t\t\tstore[user.id] = user;\n\t\t}\n\n\t\treturn store;\n\t});\n};\n","import type {\n\tICommentList,\n\tILoginResponse,\n\tIMeResponse,\n\tIMarkers,\n\tISpecies,\n\tIStats,\n\tITree,\n\tITreeUpdatePayload\n} from '$lib/types';\nimport { isAuthenticated, authState } from '$lib/stores/auth';\nimport { addUsers } from '$lib/stores/userStore';\nimport { get } from 'svelte/store';\nimport { API_ROOT } from '$lib/env';\n\ninterface Response<T> {\n\tstatus: number;\n\tdata: T;\n}\n\nexport class ApiClient {\n\tprivate root: string;\n\n\tconstructor() {\n\t\tthis.root = API_ROOT;\n\t\tconsole.debug(`[api] Root: ${this.root}`);\n\t}\n\n\tpublic async getTree(id: string): Promise<Response<ITree>> {\n\t\tconsole.debug(`[api] Getting tree ${id}`);\n\t\tconst res = await this.request('GET', `v1/trees/${id}`);\n\n\t\tif (res.status === 200) {\n\t\t\taddUsers(res.data.users);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic async getStats(): Promise<Response<IStats>> {\n\t\tconsole.debug(`[api] Getting stats`);\n\t\treturn await this.request('GET', 'v1/trees/stats');\n\t}\n\n\tpublic async getMe(token: string): Promise<Response<IMeResponse>> {\n\t\treturn await this.request('GET', 'v1/me', {\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\tAuthorization: `Bearer ${token}`\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async getMarkers(\n\t\tn: number,\n\t\te: number,\n\t\ts: number,\n\t\tw: number,\n\t\tsearch?: string | undefined\n\t): Promise<Response<IMarkers>> {\n\t\tconst params = new URLSearchParams({\n\t\t\tn: n.toString(),\n\t\t\te: e.toString(),\n\t\t\ts: s.toString(),\n\t\t\tw: w.toString()\n\t\t});\n\n\t\tif (search) {\n\t\t\tparams.set('search', search);\n\t\t}\n\n\t\treturn await this.request('GET', 'v1/trees?' + params.toString());\n\t}\n\n\tpublic async loginWithGoogle(token: string): Promise<Response<ILoginResponse>> {\n\t\tconsole.debug('[api] Logging in with Google');\n\n\t\treturn await this.request('POST', 'v2/login/google', {\n\t\t\tbody: JSON.stringify({ token }),\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json'\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async updateTree(id: string, props: ITreeUpdatePayload): Promise<Response<ITree>> {\n\t\treturn await this.request('PUT', `v1/trees/${id}`, {\n\t\t\tbody: JSON.stringify(props),\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...this.getAuthHeaders()\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async addComment(id: string, message: string): Promise<Response<void>> {\n\t\tconst headers: HeadersInit = {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...this.getAuthHeaders()\n\t\t};\n\n\t\treturn await this.request('POST', `v1/trees/${id}/comments`, {\n\t\t\tbody: JSON.stringify({ message }),\n\t\t\theaders\n\t\t});\n\t}\n\n\tpublic async uploadFile(tree: string, file: File): Promise<Response<void>> {\n\t\tconst headers: HeadersInit = {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...this.getAuthHeaders()\n\t\t};\n\n\t\tconst buffer = await file.arrayBuffer();\n\t\tconst body = new Blob([buffer], { type: file.type });\n\n\t\treturn await this.request('POST', `v1/trees/${tree}/files`, {\n\t\t\tbody,\n\t\t\theaders\n\t\t});\n\t}\n\n\tpublic async searchSpecies(query: string): Promise<Response<ISpecies>> {\n\t\tconst params = new URLSearchParams({ query });\n\t\treturn await this.request('GET', `v1/species/search?${params}`);\n\t}\n\n\tpublic async getTreeComments(id: string): Promise<Response<ICommentList>> {\n\t\treturn await this.request('GET', `v1/trees/${id}/comments`);\n\t}\n\n\t/**\n\t * Send a raw request to the API.\n\t *\n\t * @docs https://developer.mozilla.org/en-US/docs/Web/API/RequestInit\n\t */\n\tprivate async request<T>(\n\t\tmethod: string,\n\t\tpath: string,\n\t\toptions?: RequestInit\n\t): Promise<Response<T>> {\n\t\tconsole.debug(`[api] Requesting ${method} ${this.root}${path}`);\n\n\t\tconst request = new Request(this.root + path, {\n\t\t\tmethod,\n\t\t\t...options\n\t\t});\n\n\t\tconst response = await fetch(request);\n\t\tconst data = response.status == 202 ? undefined : await response.json();\n\n\t\treturn {\n\t\t\tstatus: response.status,\n\t\t\tdata\n\t\t};\n\t}\n\n\tprivate getAuthHeaders(): HeadersInit {\n\t\tif (get(isAuthenticated)) {\n\t\t\tconst token = get(authState)?.token;\n\n\t\t\tif (token) {\n\t\t\t\treturn {\n\t\t\t\t\tAuthorization: `Bearer ${token}`\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn {};\n\t}\n}\n\nexport const apiClient = new ApiClient();\n"],"names":["isRedirect","error","hasValidLocation","hasValidStatus","isHttpError","err","sendErrorToSentry","objectifiedErr","objectify","captureException","wrapLoadWithSentry","origLoad","wrappingTarget","thisArg","args","event","patchedEvent","addNonEnumerableProperty","routeIdDescriptor","routeId","startSpan","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","handleCallbackErrors","userStore","writable","getUser","derived","$userStore","id","addUsers","users","store","user","ApiClient","__publicField","API_ROOT","res","token","n","e","s","w","search","params","props","message","headers","tree","file","buffer","body","query","method","path","options","request","response","data","get","isAuthenticated","_a","authState","apiClient"],"mappings":"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","x_google_ignoreList":[0,1]}