{"version":3,"file":"disclose-version.DY74GWiO.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/elements/misc.js","../../../../../../node_modules/svelte/src/internal/client/dom/reconciler.js","../../../../../../node_modules/svelte/src/internal/client/dom/template.js","../../../../../../node_modules/svelte/src/version.js","../../../../../../node_modules/svelte/src/internal/disclose-version.js"],"sourcesContent":["import { hydrating } from '../hydration.js';\nimport { clear_text_content, get_first_child } from '../operations.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function autofocus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (document.activeElement === body) {\n\t\t\t\tdom.focus();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (hydrating && get_first_child(dom) !== null) {\n\t\tclear_text_content(dom);\n\t}\n}\n\nlet listening_to_form_reset = false;\n\nexport function add_form_reset_listener() {\n\tif (!listening_to_form_reset) {\n\t\tlistening_to_form_reset = true;\n\t\tdocument.addEventListener(\n\t\t\t'reset',\n\t\t\t(evt) => {\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\n\t\t\t\t// elements have not updated to their reset values yet\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (!evt.defaultPrevented) {\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\te.__on_r?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n\t\t\t{ capture: true }\n\t\t);\n\t}\n}\n","/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { create_text, get_first_child } from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { active_effect } from '../runtime.js';\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\n\n/**\n * @param {TemplateNode} start\n * @param {TemplateNode | null} end\n */\nexport function assign_nodes(start, end) {\n\tvar effect = /** @type {Effect} */ (active_effect);\n\tif (effect.nodes_start === null) {\n\t\teffect.nodes_start = start;\n\t\teffect.nodes_end = end;\n\t}\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(content, flags) {\n\tvar fn = template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function ns_template(content, flags, ns = 'svg') {\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\n\t\t\tvar root = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (is_fragment) {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (get_first_child(root)) {\n\t\t\t\t\tnode.appendChild(/** @type {Node} */ (get_first_child(root)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(root));\n\t\t\t}\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(content, flags) {\n\tvar fn = ns_template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mathml_template(content, flags) {\n\treturn ns_template(content, flags, 'math');\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n * @returns {Node | Node[]}\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return node;\n\n\tconst is_fragment = node.nodeType === 11;\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tconst effect = /** @type {Effect} */ (active_effect);\n\n\tfor (const script of scripts) {\n\t\tconst clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\n\t\t// The script has changed - if it's at the edges, the effect now points at dead nodes\n\t\tif (is_fragment ? node.firstChild === script : node === script) {\n\t\t\teffect.nodes_start = clone;\n\t\t}\n\t\tif (is_fragment ? node.lastChild === script : node === script) {\n\t\t\teffect.nodes_end = clone;\n\t\t}\n\n\t\tscript.replaceWith(clone);\n\t}\n\treturn node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {any} value\n */\nexport function text(value = '') {\n\tif (!hydrating) {\n\t\tvar t = create_text(value + '');\n\t\tassign_nodes(t, t);\n\t\treturn t;\n\t}\n\n\tvar node = hydrate_node;\n\n\tif (node.nodeType !== 3) {\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\n\t\tnode.before((node = create_text()));\n\t\tset_hydrate_node(node);\n\t}\n\n\tassign_nodes(node, node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tassign_nodes(hydrate_node, null);\n\t\treturn hydrate_node;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar start = document.createComment('');\n\tvar anchor = create_text();\n\tfrag.append(start, anchor);\n\n\tassign_nodes(start, anchor);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) {\n\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\thydrate_next();\n\t\treturn;\n\t}\n\n\tif (anchor === null) {\n\t\t// edge case â€” void `<svelte:element>` with content\n\t\treturn;\n\t}\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '5.12.0';\nexport const PUBLIC_VERSION = '5';\n","import { PUBLIC_VERSION } from '../version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);\n"],"names":["remove_textarea_child","dom","hydrating","get_first_child","clear_text_content","listening_to_form_reset","add_form_reset_listener","evt","e","_a","create_fragment_from_html","html","elem","assign_nodes","start","end","effect","active_effect","template","content","flags","is_fragment","TEMPLATE_FRAGMENT","use_import_node","TEMPLATE_USE_IMPORT_NODE","node","has_start","hydrate_node","clone","template_with_script","fn","run_scripts","ns_template","ns","wrapped","fragment","root","scripts","script","attribute","text","value","t","create_text","set_hydrate_node","comment","frag","anchor","append","hydrate_next","PUBLIC_VERSION"],"mappings":"kaA4BO,SAASA,EAAsBC,EAAK,CACtCC,GAAaC,EAAgBF,CAAG,IAAM,MACzCG,EAAmBH,CAAG,CAExB,CAEA,IAAII,EAA0B,GAEvB,SAASC,GAA0B,CACpCD,IACJA,EAA0B,GAC1B,SAAS,iBACR,QACCE,GAAQ,CAGR,QAAQ,UAAU,KAAK,IAAM,OAC5B,GAAI,CAACA,EAAI,iBACR,UAAWC,KAAoCD,EAAI,OAAQ,UAE1DE,EAAAD,EAAE,SAAF,MAAAC,EAAA,KAAAD,EAGP,CAAK,CACD,EAED,CAAE,QAAS,EAAI,CACf,EAEH,CCxDO,SAASE,EAA0BC,EAAM,CAC/C,IAAIC,EAAO,SAAS,cAAc,UAAU,EAC5C,OAAAA,EAAK,UAAYD,EACVC,EAAK,OACb,CCMO,SAASC,EAAaC,EAAOC,EAAK,CACxC,IAAIC,EAAgCC,EAChCD,EAAO,cAAgB,OAC1BA,EAAO,YAAcF,EACrBE,EAAO,UAAYD,EAErB,CAQO,SAASG,EAASC,EAASC,EAAO,CACxC,IAAIC,GAAeD,EAAQE,KAAuB,EAC9CC,GAAmBH,EAAQI,KAA8B,EAGzDC,EAMAC,EAAY,CAACP,EAAQ,WAAW,KAAK,EAEzC,MAAO,IAAM,CACZ,GAAIjB,EACH,OAAAW,EAAac,EAAc,IAAI,EACxBA,EAGJF,IAAS,SACZA,EAAOf,EAA0BgB,EAAYP,EAAU,MAAQA,CAAO,EACjEE,IAAaI,EAA4BtB,EAAgBsB,CAAI,IAGnE,IAAIG,EACHL,EAAkB,SAAS,WAAWE,EAAM,EAAI,EAAIA,EAAK,UAAU,EAAI,EAGxE,GAAIJ,EAAa,CAChB,IAAIP,EAAqCX,EAAgByB,CAAK,EAC1Db,EAAmCa,EAAM,UAE7Cf,EAAaC,EAAOC,CAAG,CAC1B,MACGF,EAAae,EAAOA,CAAK,EAG1B,OAAOA,CACP,CACF,CAQO,SAASC,EAAqBV,EAASC,EAAO,CACpD,IAAIU,EAAKZ,EAASC,EAASC,CAAK,EAChC,MAAO,IAAMW,EAAuDD,GAAM,CAC3E,CASO,SAASE,EAAYb,EAASC,EAAOa,EAAK,MAAO,CAKvD,IAAIP,EAAY,CAACP,EAAQ,WAAW,KAAK,EAGrCe,EAAU,IAAID,CAAE,IAAIP,EAAYP,EAAU,MAAQA,CAAO,KAAKc,CAAE,IAGhER,EAEJ,MAAO,IAAM,CACZ,GAAIvB,EACH,OAAAW,EAAac,EAAc,IAAI,EACxBA,EAGR,GAAI,CAACF,EAAM,CACV,IAAIU,EAA4CzB,EAA0BwB,CAAO,EAC7EE,EAA+BjC,EAAgBgC,CAAQ,EAQ1DV,EAA+BtB,EAAgBiC,CAAI,CAEvD,CAEE,IAAIR,EAAqCH,EAAK,UAAU,EAAI,EAQ3D,OAAAZ,EAAae,EAAOA,CAAK,EAGnBA,CACP,CACF,CA6BA,SAASG,EAAYN,EAAM,CAE1B,GAAIvB,EAAW,OAAOuB,EAEtB,MAAMJ,EAAcI,EAAK,WAAa,GAChCY,EACuBZ,EAAM,UAAY,SAC3C,CAAmCA,CAAI,EACvCA,EAAK,iBAAiB,QAAQ,EAC5BT,EAAgCC,EAEtC,UAAWqB,KAAUD,EAAS,CAC7B,MAAMT,EAAQ,SAAS,cAAc,QAAQ,EAC7C,QAASW,KAAaD,EAAO,WAC5BV,EAAM,aAAaW,EAAU,KAAMA,EAAU,KAAK,EAGnDX,EAAM,YAAcU,EAAO,aAGvBjB,EAAcI,EAAK,aAAea,EAASb,IAASa,KACvDtB,EAAO,YAAcY,IAElBP,EAAcI,EAAK,YAAca,EAASb,IAASa,KACtDtB,EAAO,UAAYY,GAGpBU,EAAO,YAAYV,CAAK,CAC1B,CACC,OAAOH,CACR,CAMO,SAASe,EAAKC,EAAQ,GAAI,CAChC,GAAI,CAACvC,EAAW,CACf,IAAIwC,EAAIC,EAAYF,EAAQ,EAAE,EAC9B,OAAA5B,EAAa6B,EAAGA,CAAC,EACVA,CACT,CAEC,IAAIjB,EAAOE,EAEX,OAAIF,EAAK,WAAa,IAErBA,EAAK,OAAQA,EAAOkB,GAAe,EACnCC,EAAiBnB,CAAI,GAGtBZ,EAAaY,EAAMA,CAAI,EAChBA,CACR,CAEO,SAASoB,GAAU,CAEzB,GAAI3C,EACH,OAAAW,EAAac,EAAc,IAAI,EACxBA,EAGR,IAAImB,EAAO,SAAS,uBAAwB,EACxChC,EAAQ,SAAS,cAAc,EAAE,EACjCiC,EAASJ,EAAa,EAC1B,OAAAG,EAAK,OAAOhC,EAAOiC,CAAM,EAEzBlC,EAAaC,EAAOiC,CAAM,EAEnBD,CACR,CAQO,SAASE,EAAOD,EAAQ9C,EAAK,CACnC,GAAIC,EAAW,CACSe,EAAe,UAAYU,EAClDsB,EAAc,EACd,MACF,CAEKF,IAAW,MAKfA,EAAO,OAA4B9C,CAAK,CACzC,kJCjPO,MAAMiD,EAAiB,ICP1B,OAAO,OAAW,MAEpB,OAAO,WAAP,OAAO,SAAa,CAAE,EAAG,IAAI,OAAS,EAAE,IAAIA,CAAc","x_google_ignoreList":[0,1,2,3,4]}