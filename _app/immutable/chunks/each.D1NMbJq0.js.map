{"version":3,"file":"each.D1NMbJq0.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/blocks/each.js"],"sourcesContent":["/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { INERT } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\nimport { active_effect, active_reaction } from '../../runtime.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, EachItem>} items_map\n */\nfunction pause_effects(state, items, controlled_anchor, items_map) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(state, items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {EachState} */\n\tvar state = { flags, items: new Map(), first: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\tvar was_empty = false;\n\n\tblock(() => {\n\t\tvar collection = get_collection();\n\n\t\tvar array = is_array(collection)\n\t\t\t? collection\n\t\t\t: collection == null\n\t\t\t\t? []\n\t\t\t\t: array_from(collection);\n\n\t\tvar length = array.length;\n\n\t\tif (was_empty && length === 0) {\n\t\t\t// ignore updates if the array is empty,\n\t\t\t// and it already was empty on previous run\n\t\t\treturn;\n\t\t}\n\t\twas_empty = length === 0;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch â€” remove the server-rendered DOM and start over\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {EachItem | null} */\n\t\t\tvar prev = null;\n\n\t\t\t/** @type {EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\thydrate_node.nodeType === 8 &&\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t\t) {\n\t\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(hydrate_node, state, prev, null, value, key, i, render_fn, flags);\n\t\t\t\tstate.items.set(key, item);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\tset_hydrate_node(remove_nodes());\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\tvar effect = /** @type {Effect} */ (active_reaction);\n\t\t\treconcile(array, state, anchor, render_fn, flags, (effect.f & INERT) !== 0, get_key);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget_collection();\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {Array<V>} array\n * @param {EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>) => void} render_fn\n * @param {number} flags\n * @param {boolean} is_inert\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, is_inert, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.first;\n\tvar current = first;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar seen;\n\n\t/** @type {EachItem | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar to_animate;\n\n\t/** @type {EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\n\n\t\t\tprev = create_item(\n\t\t\t\tchild_anchor,\n\t\t\t\tstate,\n\t\t\t\tprev,\n\t\t\t\tprev === null ? state.first : prev.next,\n\t\t\t\tvalue,\n\t\t\t\tkey,\n\t\t\t\ti,\n\t\t\t\trender_fn,\n\t\t\t\tflags\n\t\t\t);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen !== undefined && seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\n\t\t\t\t\tlink(state, prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\t// If the each block isn't inert and an item has an effect that is already inert,\n\t\t\t\t// skip over adding it to our seen Set as the item is already being handled\n\t\t\t\tif (is_inert || (current.e.f & INERT) === 0) {\n\t\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\t}\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\n\n\t\twhile (current !== null) {\n\t\t\t// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif (is_inert || (current.e.f & INERT) === 0) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor, items);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @type {Effect} */ (active_effect).first = state.first && state.first.e;\n\t/** @type {Effect} */ (active_effect).last = prev && prev.e;\n}\n\n/**\n * @param {EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tinternal_set(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>) => void} render_fn\n * @param {number} flags\n * @returns {EachItem}\n */\nfunction create_item(anchor, state, prev, next, value, key, index, render_fn, flags) {\n\tvar previous_each_item = current_each_item;\n\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n\n\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\n\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\t/** @type {EachItem} */\n\tvar item = {\n\t\ti,\n\t\tv,\n\t\tk: key,\n\t\ta: null,\n\t\t// @ts-expect-error\n\t\te: null,\n\t\tprev,\n\t\tnext\n\t};\n\n\tcurrent_each_item = item;\n\n\ttry {\n\t\titem.e = branch(() => render_fn(anchor, v, i), hydrating);\n\n\t\titem.e.prev = prev && prev.e;\n\t\titem.e.next = next && next.e;\n\n\t\tif (prev === null) {\n\t\t\tstate.first = item;\n\t\t} else {\n\t\t\tprev.next = item;\n\t\t\tprev.e.next = item.e;\n\t\t}\n\n\t\tif (next !== null) {\n\t\t\tnext.prev = item;\n\t\t\tnext.e.prev = item.e;\n\t\t}\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {EachItem} item\n * @param {EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\n\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.first = next;\n\t} else {\n\t\tprev.next = next;\n\t\tprev.e.next = next && next.e;\n\t}\n\n\tif (next !== null) {\n\t\tnext.prev = prev;\n\t\tnext.e.prev = prev && prev.e;\n\t}\n}\n"],"names":["current_each_item","index","_","i","pause_effects","state","items","controlled_anchor","items_map","transitions","length","pause_children","is_controlled","parent_node","clear_text_content","link","run_out_transitions","item","destroy_effect","each","node","flags","get_collection","get_key","render_fn","fallback_fn","anchor","EACH_IS_CONTROLLED","hydrating","set_hydrate_node","get_first_child","create_text","hydrate_next","fallback","was_empty","block","collection","array","is_array","array_from","mismatch","is_else","HYDRATION_START_ELSE","remove_nodes","set_hydrating","prev","hydrate_node","HYDRATION_END","value","key","create_item","effect","active_reaction","reconcile","INERT","resume_effect","branch","pause_effect","is_inert","is_animated","EACH_IS_ANIMATED","should_update","EACH_ITEM_REACTIVE","EACH_INDEX_REACTIVE","first","current","seen","to_animate","matched","stashed","_a","child_anchor","update_item","_b","start","j","a","b","move","to_destroy","destroy_length","_c","_d","queue_micro_task","active_effect","type","internal_set","next","previous_each_item","reactive","mutable","EACH_ITEM_IMMUTABLE","v","mutable_source","source","end","dest","next_node","get_next_sibling"],"mappings":"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","x_google_ignoreList":[0]}