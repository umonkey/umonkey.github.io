{"version":3,"file":"exports.B6LD4xG7.js","sources":["../../../../../../node_modules/@sentry/core/build/esm/utils-hoist/syncpromise.js","../../../../../../node_modules/@sentry/core/build/esm/eventProcessors.js","../../../../../../node_modules/@sentry/core/build/esm/utils-hoist/debug-ids.js","../../../../../../node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js","../../../../../../node_modules/@sentry/core/build/esm/utils/prepareEvent.js","../../../../../../node_modules/@sentry/core/build/esm/exports.js"],"sourcesContent":["import { isThenable } from './is.js';\n\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/** SyncPromise internal states */\nvar States; (function (States) {\n  /** Pending */\n  const PENDING = 0; States[States[\"PENDING\"] = PENDING] = \"PENDING\";\n  /** Resolved / OK */\n  const RESOLVED = 1; States[States[\"RESOLVED\"] = RESOLVED] = \"RESOLVED\";\n  /** Rejected / Error */\n  const REJECTED = 2; States[States[\"REJECTED\"] = REJECTED] = \"REJECTED\";\n})(States || (States = {}));\n\n// Overloads so we can call resolvedSyncPromise without arguments and generic argument\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nfunction resolvedSyncPromise(value) {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nfunction rejectedSyncPromise(reason) {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise {\n\n   constructor(\n    executor,\n  ) {SyncPromise.prototype.__init.call(this);SyncPromise.prototype.__init2.call(this);SyncPromise.prototype.__init3.call(this);SyncPromise.prototype.__init4.call(this);\n    this._state = States.PENDING;\n    this._handlers = [];\n\n    try {\n      executor(this._resolve, this._reject);\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n\n  /** JSDoc */\n   then(\n    onfulfilled,\n    onrejected,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: ¯\\_(ツ)_/¯\n            // TODO: FIXME\n            resolve(result );\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** JSDoc */\n   catch(\n    onrejected,\n  ) {\n    return this.then(val => val, onrejected);\n  }\n\n  /** JSDoc */\n   finally(onfinally) {\n    return new SyncPromise((resolve, reject) => {\n      let val;\n      let isRejected;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val );\n      });\n    });\n  }\n\n  /** JSDoc */\n    __init() {this._resolve = (value) => {\n    this._setResult(States.RESOLVED, value);\n  };}\n\n  /** JSDoc */\n    __init2() {this._reject = (reason) => {\n    this._setResult(States.REJECTED, reason);\n  };}\n\n  /** JSDoc */\n    __init3() {this._setResult = (state, value) => {\n    if (this._state !== States.PENDING) {\n      return;\n    }\n\n    if (isThenable(value)) {\n      void (value ).then(this._resolve, this._reject);\n      return;\n    }\n\n    this._state = state;\n    this._value = value;\n\n    this._executeHandlers();\n  };}\n\n  /** JSDoc */\n    __init4() {this._executeHandlers = () => {\n    if (this._state === States.PENDING) {\n      return;\n    }\n\n    const cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === States.RESOLVED) {\n        handler[1](this._value );\n      }\n\n      if (this._state === States.REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  };}\n}\n\nexport { SyncPromise, rejectedSyncPromise, resolvedSyncPromise };\n//# sourceMappingURL=syncpromise.js.map\n","import { DEBUG_BUILD } from './debug-build.js';\nimport { isThenable } from './utils-hoist/is.js';\nimport { logger } from './utils-hoist/logger.js';\nimport { SyncPromise } from './utils-hoist/syncpromise.js';\n\n/**\n * Process an array of event processors, returning the processed event (or `null` if the event was dropped).\n */\nfunction notifyEventProcessors(\n  processors,\n  event,\n  hint,\n  index = 0,\n) {\n  return new SyncPromise((resolve, reject) => {\n    const processor = processors[index];\n    if (event === null || typeof processor !== 'function') {\n      resolve(event);\n    } else {\n      const result = processor({ ...event }, hint) ;\n\n      DEBUG_BUILD && processor.id && result === null && logger.log(`Event processor \"${processor.id}\" dropped event`);\n\n      if (isThenable(result)) {\n        void result\n          .then(final => notifyEventProcessors(processors, final, hint, index + 1).then(resolve))\n          .then(null, reject);\n      } else {\n        void notifyEventProcessors(processors, result, hint, index + 1)\n          .then(resolve)\n          .then(null, reject);\n      }\n    }\n  });\n}\n\nexport { notifyEventProcessors };\n//# sourceMappingURL=eventProcessors.js.map\n","import { GLOBAL_OBJ } from './worldwide.js';\n\nlet parsedStackResults;\nlet lastKeysCount;\nlet cachedFilenameDebugIds;\n\n/**\n * Returns a map of filenames to debug identifiers.\n */\nfunction getFilenameToDebugIdMap(stackParser) {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return {};\n  }\n\n  const debugIdKeys = Object.keys(debugIdMap);\n\n  // If the count of registered globals hasn't changed since the last call, we\n  // can just return the cached result.\n  if (cachedFilenameDebugIds && debugIdKeys.length === lastKeysCount) {\n    return cachedFilenameDebugIds;\n  }\n\n  lastKeysCount = debugIdKeys.length;\n\n  // Build a map of filename -> debug_id.\n  cachedFilenameDebugIds = debugIdKeys.reduce((acc, stackKey) => {\n    if (!parsedStackResults) {\n      parsedStackResults = {};\n    }\n\n    const result = parsedStackResults[stackKey];\n\n    if (result) {\n      acc[result[0]] = result[1];\n    } else {\n      const parsedStack = stackParser(stackKey);\n\n      for (let i = parsedStack.length - 1; i >= 0; i--) {\n        const stackFrame = parsedStack[i];\n        const filename = stackFrame && stackFrame.filename;\n        const debugId = debugIdMap[stackKey];\n\n        if (filename && debugId) {\n          acc[filename] = debugId;\n          parsedStackResults[stackKey] = [filename, debugId];\n          break;\n        }\n      }\n    }\n\n    return acc;\n  }, {});\n\n  return cachedFilenameDebugIds;\n}\n\n/**\n * Returns a list of debug images for the given resources.\n */\nfunction getDebugImagesForResources(\n  stackParser,\n  resource_paths,\n) {\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n\n  if (!filenameDebugIdMap) {\n    return [];\n  }\n\n  const images = [];\n  for (const path of resource_paths) {\n    if (path && filenameDebugIdMap[path]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: path,\n        debug_id: filenameDebugIdMap[path] ,\n      });\n    }\n  }\n\n  return images;\n}\n\nexport { getDebugImagesForResources, getFilenameToDebugIdMap };\n//# sourceMappingURL=debug-ids.js.map\n","import { getDynamicSamplingContextFromSpan } from '../tracing/dynamicSamplingContext.js';\nimport { dropUndefinedKeys } from '../utils-hoist/object.js';\nimport { merge } from './merge.js';\nimport { spanToTraceContext, getRootSpan, spanToJSON } from './spanUtils.js';\n\n/**\n * Applies data from the scope to the event and runs all event processors on it.\n */\nfunction applyScopeDataToEvent(event, data) {\n  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;\n\n  // Apply general data\n  applyDataToEvent(event, data);\n\n  // We want to set the trace context for normal events only if there isn't already\n  // a trace context on the event. There is a product feature in place where we link\n  // errors with transaction and it relies on that.\n  if (span) {\n    applySpanToEvent(event, span);\n  }\n\n  applyFingerprintToEvent(event, fingerprint);\n  applyBreadcrumbsToEvent(event, breadcrumbs);\n  applySdkMetadataToEvent(event, sdkProcessingMetadata);\n}\n\n/** Merge data of two scopes together. */\nfunction mergeScopeData(data, mergeData) {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    sdkProcessingMetadata,\n    breadcrumbs,\n    fingerprint,\n    eventProcessors,\n    attachments,\n    propagationContext,\n    transactionName,\n    span,\n  } = mergeData;\n\n  mergeAndOverwriteScopeData(data, 'extra', extra);\n  mergeAndOverwriteScopeData(data, 'tags', tags);\n  mergeAndOverwriteScopeData(data, 'user', user);\n  mergeAndOverwriteScopeData(data, 'contexts', contexts);\n\n  data.sdkProcessingMetadata = merge(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);\n\n  if (level) {\n    data.level = level;\n  }\n\n  if (transactionName) {\n    data.transactionName = transactionName;\n  }\n\n  if (span) {\n    data.span = span;\n  }\n\n  if (breadcrumbs.length) {\n    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];\n  }\n\n  if (fingerprint.length) {\n    data.fingerprint = [...data.fingerprint, ...fingerprint];\n  }\n\n  if (eventProcessors.length) {\n    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];\n  }\n\n  if (attachments.length) {\n    data.attachments = [...data.attachments, ...attachments];\n  }\n\n  data.propagationContext = { ...data.propagationContext, ...propagationContext };\n}\n\n/**\n * Merges certain scope data. Undefined values will overwrite any existing values.\n * Exported only for tests.\n */\nfunction mergeAndOverwriteScopeData\n\n(data, prop, mergeVal) {\n  data[prop] = merge(data[prop], mergeVal, 1);\n}\n\nfunction applyDataToEvent(event, data) {\n  const { extra, tags, user, contexts, level, transactionName } = data;\n\n  const cleanedExtra = dropUndefinedKeys(extra);\n  if (cleanedExtra && Object.keys(cleanedExtra).length) {\n    event.extra = { ...cleanedExtra, ...event.extra };\n  }\n\n  const cleanedTags = dropUndefinedKeys(tags);\n  if (cleanedTags && Object.keys(cleanedTags).length) {\n    event.tags = { ...cleanedTags, ...event.tags };\n  }\n\n  const cleanedUser = dropUndefinedKeys(user);\n  if (cleanedUser && Object.keys(cleanedUser).length) {\n    event.user = { ...cleanedUser, ...event.user };\n  }\n\n  const cleanedContexts = dropUndefinedKeys(contexts);\n  if (cleanedContexts && Object.keys(cleanedContexts).length) {\n    event.contexts = { ...cleanedContexts, ...event.contexts };\n  }\n\n  if (level) {\n    event.level = level;\n  }\n\n  // transaction events get their `transaction` from the root span name\n  if (transactionName && event.type !== 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\nfunction applyBreadcrumbsToEvent(event, breadcrumbs) {\n  const mergedBreadcrumbs = [...(event.breadcrumbs || []), ...breadcrumbs];\n  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;\n}\n\nfunction applySdkMetadataToEvent(event, sdkProcessingMetadata) {\n  event.sdkProcessingMetadata = {\n    ...event.sdkProcessingMetadata,\n    ...sdkProcessingMetadata,\n  };\n}\n\nfunction applySpanToEvent(event, span) {\n  event.contexts = {\n    trace: spanToTraceContext(span),\n    ...event.contexts,\n  };\n\n  event.sdkProcessingMetadata = {\n    dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),\n    ...event.sdkProcessingMetadata,\n  };\n\n  const rootSpan = getRootSpan(span);\n  const transactionName = spanToJSON(rootSpan).description;\n  if (transactionName && !event.transaction && event.type === 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\n/**\n * Applies fingerprint from the scope to the event if there's one,\n * uses message if there's one instead or get rid of empty fingerprint\n */\nfunction applyFingerprintToEvent(event, fingerprint) {\n  // Make sure it's an array first and we actually have something in place\n  event.fingerprint = event.fingerprint\n    ? Array.isArray(event.fingerprint)\n      ? event.fingerprint\n      : [event.fingerprint]\n    : [];\n\n  // If we have something on the scope, then merge it with event\n  if (fingerprint) {\n    event.fingerprint = event.fingerprint.concat(fingerprint);\n  }\n\n  // If we have no data at all, remove empty array default\n  if (event.fingerprint && !event.fingerprint.length) {\n    delete event.fingerprint;\n  }\n}\n\nexport { applyScopeDataToEvent, mergeAndOverwriteScopeData, mergeScopeData };\n//# sourceMappingURL=applyScopeDataToEvent.js.map\n","import { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getGlobalScope } from '../currentScopes.js';\nimport { notifyEventProcessors } from '../eventProcessors.js';\nimport { Scope } from '../scope.js';\nimport { getFilenameToDebugIdMap } from '../utils-hoist/debug-ids.js';\nimport { uuid4, addExceptionMechanism } from '../utils-hoist/misc.js';\nimport { normalize } from '../utils-hoist/normalize.js';\nimport { truncate } from '../utils-hoist/string.js';\nimport { dateTimestampInSeconds } from '../utils-hoist/time.js';\nimport { mergeScopeData, applyScopeDataToEvent } from './applyScopeDataToEvent.js';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(\n  options,\n  event,\n  hint,\n  scope,\n  client,\n  isolationScope,\n) {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  if (client) {\n    client.emit('applyFrameMetadata', event);\n  }\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n\n  const clientEventProcessors = client ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Scope.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getGlobalScope().getScopeData();\n\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    mergeScopeData(data, isolationData);\n  }\n\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    mergeScopeData(data, finalScopeData);\n  }\n\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n\n  applyScopeDataToEvent(prepared, data);\n\n  const eventProcessors = [\n    ...clientEventProcessors,\n    // Run scope event processors _after_ all other processors\n    ...data.eventProcessors,\n  ];\n\n  const result = notifyEventProcessors(eventProcessors, prepared, hint);\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n * Enhances event using the client configuration.\n * It takes care of all \"static\" values like environment, release and `dist`,\n * as well as truncating overly long values.\n *\n * Only exported for tests.\n *\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  // empty strings do not make sense for environment, release, and dist\n  // so we handle them the same as if they were not provided\n  event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;\n\n  if (!event.release && release) {\n    event.release = release;\n  }\n\n  if (!event.dist && dist) {\n    event.dist = dist;\n  }\n\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n\n  const exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n\n  const request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (filenameDebugIdMap && frame.filename) {\n          frame.debug_id = filenameDebugIdMap[frame.filename];\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap = {};\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (frame.debug_id) {\n          if (frame.abs_path) {\n            filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n          } else if (frame.filename) {\n            filenameDebugIdMap[frame.filename] = frame.debug_id;\n          }\n          delete frame.debug_id;\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id,\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      return {\n        ...span,\n        ...(span.data && {\n          data: normalize(span.data, depth, maxBreadth),\n        }),\n      };\n    });\n  }\n\n  // event.contexts.flags (FeatureFlagContext) stores context for our feature\n  // flag integrations. It has a greater nesting depth than our other typed\n  // Contexts, so we re-normalize with a fixed depth of 3 here. We do not want\n  // to skip this in case of conflicting, user-provided context.\n  if (event.contexts && event.contexts.flags && normalized.contexts) {\n    normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);\n  }\n\n  return normalized;\n}\n\nfunction getFinalScope(\n  scope,\n  captureContext,\n) {\n  if (!captureContext) {\n    return scope;\n  }\n\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nfunction parseEventHintOrCaptureContext(\n  hint,\n) {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return { captureContext: hint };\n  }\n\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint,\n    };\n  }\n\n  return hint;\n}\n\nfunction hintIsScopeOrFunction(\n  hint,\n) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\n\nconst captureContextKeys = [\n  'user',\n  'level',\n  'extra',\n  'contexts',\n  'tags',\n  'fingerprint',\n  'requestSession',\n  'propagationContext',\n] ;\n\nfunction hintIsScopeContext(hint) {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key ));\n}\n\nexport { applyClientOptions, applyDebugIds, applyDebugMeta, parseEventHintOrCaptureContext, prepareEvent };\n//# sourceMappingURL=prepareEvent.js.map\n","import { DEFAULT_ENVIRONMENT } from './constants.js';\nimport { getCurrentScope, getIsolationScope, getClient, withIsolationScope } from './currentScopes.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { makeSession, updateSession, closeSession } from './session.js';\nimport { isThenable } from './utils-hoist/is.js';\nimport { logger } from './utils-hoist/logger.js';\nimport { uuid4 } from './utils-hoist/misc.js';\nimport { timestampInSeconds } from './utils-hoist/time.js';\nimport { GLOBAL_OBJ } from './utils-hoist/worldwide.js';\nimport { parseEventHintOrCaptureContext } from './utils/prepareEvent.js';\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nfunction captureException(exception, hint) {\n  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nfunction captureMessage(message, captureContext) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentScope().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nfunction captureEvent(event, hint) {\n  return getCurrentScope().captureEvent(event, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nfunction setContext(name, context) {\n  getIsolationScope().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  getIsolationScope().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  getIsolationScope().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  getIsolationScope().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  getIsolationScope().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  getIsolationScope().setUser(user);\n}\n\n/**\n * The last error event id of the isolation scope.\n *\n * Warning: This function really returns the last recorded error event id on the current\n * isolation scope. If you call this function after handling a certain error and another error\n * is captured in between, the last one is returned instead of the one you might expect.\n * Also, ids of events that were never sent to Sentry (for example because\n * they were dropped in `beforeSend`) could be returned.\n *\n * @returns The last event id of the isolation scope.\n */\nfunction lastEventId() {\n  return getIsolationScope().lastEventId();\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction captureCheckIn(checkIn, upsertMonitorConfig) {\n  const scope = getCurrentScope();\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && logger.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    DEBUG_BUILD && logger.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n\n  return uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction withMonitor(\n  monitorSlug,\n  callback,\n  upsertMonitorConfig,\n) {\n  const checkInId = captureCheckIn({ monitorSlug, status: 'in_progress' }, upsertMonitorConfig);\n  const now = timestampInSeconds();\n\n  function finishCheckIn(status) {\n    captureCheckIn({ monitorSlug, status, checkInId, duration: timestampInSeconds() - now });\n  }\n\n  return withIsolationScope(() => {\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback();\n    } catch (e) {\n      finishCheckIn('error');\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      Promise.resolve(maybePromiseResult).then(\n        () => {\n          finishCheckIn('ok');\n        },\n        e => {\n          finishCheckIn('error');\n          throw e;\n        },\n      );\n    } else {\n      finishCheckIn('ok');\n    }\n\n    return maybePromiseResult;\n  });\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function flush(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  DEBUG_BUILD && logger.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function close(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  DEBUG_BUILD && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nfunction isInitialized() {\n  return !!getClient();\n}\n\n/** If the SDK is initialized & enabled. */\nfunction isEnabled() {\n  const client = getClient();\n  return !!client && client.getOptions().enabled !== false && !!client.getTransport();\n}\n\n/**\n * Add an event processor.\n * This will be added to the current isolation scope, ensuring any event that is processed in the current execution\n * context will have the processor applied.\n */\nfunction addEventProcessor(callback) {\n  getIsolationScope().addEventProcessor(callback);\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nfunction startSession(context) {\n  const client = getClient();\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const { release, environment = DEFAULT_ENVIRONMENT } = (client && client.getOptions()) || {};\n\n  // Will fetch userAgent if called from browser sdk\n  const { userAgent } = GLOBAL_OBJ.navigator || {};\n\n  const session = makeSession({\n    release,\n    environment,\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && { userAgent }),\n    ...context,\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession && currentSession.status === 'ok') {\n    updateSession(currentSession, { status: 'exited' });\n  }\n\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n\n  // TODO (v8): Remove this and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  currentScope.setSession(session);\n\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nfunction endSession() {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    closeSession(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n\n  // TODO (v8): Remove this and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  currentScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate() {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n  const client = getClient();\n  // TODO (v8): Remove currentScope and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session && client) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nfunction captureSession(end = false) {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\n\nexport { addEventProcessor, captureCheckIn, captureEvent, captureException, captureMessage, captureSession, close, endSession, flush, isEnabled, isInitialized, lastEventId, setContext, setExtra, setExtras, setTag, setTags, setUser, startSession, withMonitor };\n//# sourceMappingURL=exports.js.map\n"],"names":["States","RESOLVED","REJECTED","resolvedSyncPromise","value","SyncPromise","resolve","rejectedSyncPromise","reason","_","reject","executor","e","onfulfilled","onrejected","result","val","onfinally","isRejected","state","isThenable","cachedHandlers","handler","notifyEventProcessors","processors","event","hint","index","processor","DEBUG_BUILD","logger","final","parsedStackResults","lastKeysCount","cachedFilenameDebugIds","getFilenameToDebugIdMap","stackParser","debugIdMap","GLOBAL_OBJ","debugIdKeys","acc","stackKey","parsedStack","i","stackFrame","filename","debugId","applyScopeDataToEvent","data","fingerprint","span","breadcrumbs","sdkProcessingMetadata","applyDataToEvent","applySpanToEvent","applyFingerprintToEvent","applyBreadcrumbsToEvent","applySdkMetadataToEvent","mergeScopeData","mergeData","extra","tags","user","contexts","level","eventProcessors","attachments","propagationContext","transactionName","mergeAndOverwriteScopeData","merge","prop","mergeVal","cleanedExtra","dropUndefinedKeys","cleanedTags","cleanedUser","cleanedContexts","mergedBreadcrumbs","spanToTraceContext","getDynamicSamplingContextFromSpan","rootSpan","getRootSpan","spanToJSON","prepareEvent","options","scope","client","isolationScope","normalizeDepth","normalizeMaxBreadth","prepared","uuid4","dateTimestampInSeconds","integrations","applyClientOptions","applyIntegrationsMetadata","applyDebugIds","finalScope","getFinalScope","addExceptionMechanism","clientEventProcessors","getGlobalScope","isolationData","finalScopeData","evt","applyDebugMeta","normalizeEvent","environment","release","dist","maxValueLength","DEFAULT_ENVIRONMENT","truncate","exception","request","filenameDebugIdMap","frame","images","debug_id","integrationNames","depth","maxBreadth","normalized","b","normalize","captureContext","Scope","parseEventHintOrCaptureContext","hintIsScopeOrFunction","hintIsScopeContext","captureContextKeys","key","captureException","getCurrentScope","captureEvent","isEnabled","getClient","addEventProcessor","callback","getIsolationScope","startSession","context","currentScope","userAgent","session","makeSession","currentSession","updateSession","endSession","closeSession","_sendSessionUpdate","captureSession","end"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}