{"version":3,"file":"index.C3pZAK_X.js","sources":["../../../../../../node_modules/svelte/src/store/shared/index.js"],"sourcesContent":["/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */\n/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */\nimport { noop, run_all } from '../../internal/shared/utils.js';\nimport { safe_not_equal } from '../../internal/client/reactivity/equality.js';\nimport { subscribe_to_store } from '../utils.js';\n\n/**\n * @type {Array<SubscribeInvalidateTuple<any> | any>}\n */\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * @template T\n * @param {T} [value] initial value\n * @param {StartStopNotifier<T>} [start]\n * @returns {Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * @template T\n * @param {T} [value] initial value\n * @param {StartStopNotifier<T>} [start]\n * @returns {Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {Unsubscriber | null} */\n\tlet stop = null;\n\n\t/** @type {Set<SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\n\t/**\n\t * @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(/** @type {T} */ (value)));\n\t}\n\n\t/**\n\t * @param {Subscriber<T>} run\n\t * @param {() => void} [invalidate]\n\t * @returns {Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(/** @type {T} */ (value));\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * @template {Stores} S\n * @template T\n * @overload\n * @param {S} stores\n * @param {(values: StoresValues<S>, set: (value: T) => void, update: (fn: Updater<T>) => void) => Unsubscriber | void} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * @template {Stores} S\n * @template T\n * @overload\n * @param {S} stores\n * @param {(values: StoresValues<S>) => T} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\n/**\n * @template {Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\t/** @type {T[]} */\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = typeof result === 'function' ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe_to_store(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * @template T\n * @param {Readable<T>} store  - store to make readonly\n * @returns {Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\t// @ts-expect-error TODO i suspect the bind is unnecessary\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * @template T\n * @param {Readable<T>} store\n * @returns {T}\n */\nexport function get(store) {\n\tlet value;\n\tsubscribe_to_store(store, (_) => (value = _))();\n\t// @ts-expect-error\n\treturn value;\n}\n"],"names":["subscriber_queue","readable","value","start","writable","noop","stop","subscribers","set","new_value","safe_not_equal","run_queue","subscriber","i","update","fn","subscribe","run","invalidate","derived","stores","initial_value","single","stores_array","auto","started","values","pending","cleanup","sync","result","unsubscribers","store","subscribe_to_store","run_all","get","_"],"mappings":"sXASA,MAAMA,EAAmB,CAAE,EAUpB,SAASC,EAASC,EAAOC,EAAO,CACtC,MAAO,CACN,UAAWC,EAASF,EAAOC,CAAK,EAAE,SAClC,CACF,CAUO,SAASC,EAASF,EAAOC,EAAQE,EAAM,CAE7C,IAAIC,EAAO,KAGX,MAAMC,EAAc,IAAI,IAMxB,SAASC,EAAIC,EAAW,CACvB,GAAIC,EAAeR,EAAOO,CAAS,IAClCP,EAAQO,EACJH,GAAM,CAET,MAAMK,EAAY,CAACX,EAAiB,OACpC,UAAWY,KAAcL,EACxBK,EAAW,CAAC,EAAG,EACfZ,EAAiB,KAAKY,EAAYV,CAAK,EAExC,GAAIS,EAAW,CACd,QAASE,EAAI,EAAGA,EAAIb,EAAiB,OAAQa,GAAK,EACjDb,EAAiBa,CAAC,EAAE,CAAC,EAAEb,EAAiBa,EAAI,CAAC,CAAC,EAE/Cb,EAAiB,OAAS,CAC/B,CACA,CAEA,CAMC,SAASc,EAAOC,EAAI,CACnBP,EAAIO,EAAqBb,EAAO,CAClC,CAOC,SAASc,EAAUC,EAAKC,EAAab,EAAM,CAE1C,MAAMO,EAAa,CAACK,EAAKC,CAAU,EACnC,OAAAX,EAAY,IAAIK,CAAU,EACtBL,EAAY,OAAS,IACxBD,EAAOH,EAAMK,EAAKM,CAAM,GAAKT,GAE9BY,EAAsBf,CAAO,EACtB,IAAM,CACZK,EAAY,OAAOK,CAAU,EACzBL,EAAY,OAAS,GAAKD,IAC7BA,EAAM,EACNA,EAAO,KAER,CACH,CACC,MAAO,CAAE,IAAAE,EAAK,OAAAM,EAAQ,UAAAE,CAAW,CAClC,CAkCO,SAASG,EAAQC,EAAQL,EAAIM,EAAe,CAClD,MAAMC,EAAS,CAAC,MAAM,QAAQF,CAAM,EAE9BG,EAAeD,EAAS,CAACF,CAAM,EAAIA,EACzC,GAAI,CAACG,EAAa,MAAM,OAAO,EAC9B,MAAM,IAAI,MAAM,sDAAsD,EAEvE,MAAMC,EAAOT,EAAG,OAAS,EACzB,OAAOd,EAASoB,EAAe,CAACb,EAAKM,IAAW,CAC/C,IAAIW,EAAU,GAEd,MAAMC,EAAS,CAAE,EACjB,IAAIC,EAAU,EACVC,EAAUvB,EACd,MAAMwB,EAAO,IAAM,CAClB,GAAIF,EACH,OAEDC,EAAS,EACT,MAAME,EAASf,EAAGO,EAASI,EAAO,CAAC,EAAIA,EAAQlB,EAAKM,CAAM,EACtDU,EACHhB,EAAIsB,CAAM,EAEVF,EAAU,OAAOE,GAAW,WAAaA,EAASzB,CAEnD,EACK0B,EAAgBR,EAAa,IAAI,CAACS,EAAOnB,IAC9CoB,EACCD,EACC9B,GAAU,CACVwB,EAAOb,CAAC,EAAIX,EACZyB,GAAW,EAAE,GAAKd,GACdY,GACHI,EAAM,CAEP,EACD,IAAM,CACLF,GAAW,GAAKd,CACrB,CACA,CACG,EACD,OAAAY,EAAU,GACVI,EAAM,EACC,UAAgB,CACtBK,EAAQH,CAAa,EACrBH,EAAS,EAITH,EAAU,EACV,CACH,CAAE,CACF,CAuBO,SAASU,EAAIH,EAAO,CAC1B,IAAI9B,EACJ,OAAA+B,EAAmBD,EAAQI,GAAOlC,EAAQkC,CAAE,EAAG,EAExClC,CACR","x_google_ignoreList":[0]}